msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Sun Jul 21 21:54:44 2024\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! üéâ"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings‚Ä¶ üé≠"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! üéâ"
msgstr ""

#: Game.Levels.TacticWorld.L01_symm
msgid "The `symm` tactic."
msgstr ""

#: Game.Levels.TacticWorld.L01_symm
msgid "The `symm` tactic is easy to use and understand.\n"
"It changes goals of the form `‚ä¢ X = Y` to `‚ä¢ Y = X`. Here `X`\n"
"and `Y` can be numbers or sets or filters or anything.\n"
"\n"
"It also changes goals of the form `‚ä¢ P ‚Üî Q` to `‚ä¢ Q ‚Üî P`. You can\n"
"also make it work on hypotheses (for example `h : X = Y`), with `symm at h`.\n"
"\n"
"Why don't you try a simple example."
msgstr ""

#: Game.Levels.TacticWorld.L01_symm
msgid "If $x$ and $y$ are real numbers and $x = y$, then $y = x$."
msgstr ""

#: Game.Levels.TacticWorld.L01_symm
msgid "You can finish this using `rw`. But can you find a `rw`-free proof using `symm` and `exact`?\n"
"Try using `symm` on either the goal or `h`."
msgstr ""

#: Game.Levels.TacticWorld.L01_symm
msgid "Nice! You've now unlocked the `symm` tactic."
msgstr ""

#: Game.Levels.TacticWorld.L01_symm
msgid "## Summary\n"
"\n"
"The `symm` tactic turns goals of the form `‚ä¢ X = Y` to `‚ä¢ Y = X`,\n"
"and goals of the form `‚ä¢ P ‚Üî Q` to `‚ä¢ Q ‚Üî P`. You can use `symm at h`\n"
"to make it work on hypotheses `h : X = Y` too.\n"
"\n"
"### Example\n"
"\n"
"If the goal is `‚ä¢ 2 + 2 = 4` and you try `symm`, the goal\n"
"will become `‚ä¢ 4 = 2 + 2`.\n"
"\n"
"### Example\n"
"\n"
"If `h : S ‚äÜ T ‚Üî ‚àÄ x, x ‚àà S ‚Üí x ‚àà T` then `symm at h` will change `h`\n"
"into `(‚àÄ x, x ‚àà S ‚Üí X ‚àà T) ‚Üî S ‚äÜ T`."
msgstr ""

#: Game.Levels.TacticWorld
msgid "Tactic World"
msgstr ""

#: Game.Levels.TacticWorld
msgid "Lean has lots of tactics, and sometimes students learn about tactics which\n"
"they want to learn in the Filter Game but *can't use* because they\n"
"haven't been introduced yet.\n"
"\n"
"In Tactic World we have levels which introduce new tactics. The more\n"
"you do, the more \"power\" you will have available to you.\n"
"\n"
"Click \"Start ‚Üí\" to continue."
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "Sets are subsets of themselves"
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "If `S` and `T` are sets, then `S ‚äÜ T` means that `S` is a *subset* of `T`.\n"
"This means that every element of `S` is also an element of `T`. Let me talk you through\n"
"a proof that `S ‚äÜ S`."
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "## Summary\n"
"\n"
"If `h` is a proof of an implication `X ‚Üî Y` or an equality `X = Y`, then `rw [h]` will change\n"
"all `X`s in the goal to `Y`s. It's the way to \\\"substitute in\\\".\n"
"\n"
"### Example:\n"
"\n"
"If your goal is\n"
"```\n"
"A ‚äÜ B\n"
"```\n"
"\n"
"then\n"
"\n"
"`rw [subset_def]`\n"
"\n"
"will change the goal into `‚àÄ x ‚àà A, x ‚àà B`.\n"
"\n"
"## Variants\n"
"\n"
"Say `h : X = Y` or `h : X ‚Üî Y`.\n"
"\n"
"* `rw [‚Üê h]` (changes `Y`s to `X`s; get the back arrow by typing `\\left ` or `\\l`.)\n"
"\n"
"* `rw [h1, h2]` (a sequence of rewrites)\n"
"\n"
"* `rw [h] at h2` (changes `X`s to `Y`s in hypothesis `h2`)\n"
"\n"
"* `rw [h] at h1 h2 ‚ä¢` (changes `X`s to `Y`s in two hypotheses and the goal;\n"
"get the `‚ä¢` symbol with `\\|-`.)\n"
"\n"
"* `repeat rw [subset_def]` will change all `S ‚äÜ T`s into their definitions,\n"
"until there are no more matches.\n"
"\n"
"* `nth_rewrite 2 [h]` will change only the second `X` in the goal to `Y`.\n"
"\n"
"## Common errors\n"
"\n"
"* You need the square brackets. `rw h` is never correct.\n"
"\n"
"* If `h` is not a *proof* of an *equality* (a statement of the form `X = Y`)\n"
"or a *bi-implication* (a statement of the form `X ‚Üî Y`),\n"
"for example if `h` is a function or an implication,\n"
"then `rw` is not the tactic you want to use. For example,\n"
"`rw [P = Q]` is never correct: `P = Q` is the theorem *statement*,\n"
"not the proof. If `h : P = Q` is the proof, then `rw [h]` will work.\n"
"\n"
"## Details\n"
"\n"
"The `rw` tactic is a way to do \\\"substituting in\\\". There\n"
"are two distinct situations where you can use this tactic.\n"
"\n"
"1) Basic usage: if `h : A = B` is an assumption or\n"
"the proof of a theorem, and if the goal contains one or more `A`s, then `rw [h]`\n"
"will change them all to `B`'s. The tactic will error\n"
"if there are no `A`s in the goal.\n"
"\n"
"2) Advanced usage: Assumptions coming from theorem proofs\n"
"often have missing pieces. For example `subset_def`\n"
"is really a proof that `?‚ÇÅ ‚äÜ ?‚ÇÇ ‚Üî ‚àÄ x ‚àà ?‚ÇÅ, x ‚àà ?‚ÇÇ`,\n"
"or, if you like, a proof that `‚àÄ S T, S ‚äÜ T ‚Üî ‚àÄ x ‚àà S, x ‚àà T` because `subset_def` really\n"
"is a function, with `S` and `T` the inputs.\n"
"In this situation `rw` will look through the goal\n"
"for any subterm of the form `?‚ÇÅ ‚äÜ ?‚ÇÇ`, and the moment it\n"
"finds a match it solves for the `?`s (e.g. `?‚ÇÅ = A` and `?‚ÇÇ = B`) and then\n"
"then changes all `A ‚äÜ B`s to `‚àÄ x ‚àà A, x ‚àà B`s.\n"
"\n"
"If you can't remember the *name* of the proof of an equality or bi-implication, look it up in\n"
"the list of lemmas on the right."
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "## Summary\n"
"\n"
"If the goal is `‚àÄ x, P x`, this mean that you have to prove something for every `x`.\n"
"A mathematician might say \"Now let `x` be arbitrary\". In Lean we say `intro x`.\n"
"This will change the goal to `P x`. Note we could equally say `intro fish`,\n"
"which would change the goal to `P fish`.\n"
"\n"
"If the goal is `P ‚Üí Q`, then `intro h` will introduce `h : P` as a hypothesis,\n"
"and change the goal to `Q`. Mathematically, it says that to prove $P \\implies Q$,\n"
"we can assume $P$ and then prove $Q$.\n"
"\n"
"### Example:\n"
"\n"
"If your goal is `‚àÄ x ‚àà S, x ‚àà T` then `intro a` will give you a new variable `a`\n"
"and the goal will become `a ‚àà S ‚Üí a ‚àà T`. A second `intro h` will now give you the\n"
"hypothesis `h : a ‚àà S`, and the goal will change to `a ‚àà T`."
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "## Summary\n"
"\n"
"This tactic has two distinct uses, with two distinct syntaxes:\n"
"\n"
"1) `apply <hypothesis or proof> at <hypothesis>`.\n"
"2) `apply <hypothesis or proof>`.\n"
"\n"
"Usage 1) with the `at` is *arguing forwards*. Usage 2 is *arguing backwards*.\n"
"\n"
"Note: `apply h` or `apply h at something` will *only work* if `h` is\n"
"a *function*, for example an *implication* `h : P ‚Üí Q`.\n"
"\n"
"### More explanation\n"
"\n"
"1) If `t : P ‚Üí Q` is a proof that $P \\implies Q$, and `h : P` is a proof of `P`,\n"
"then `apply t at h` will change `h` to a proof of `Q`. The idea is that if\n"
"you know `P` is true, then you can deduce from `t` that `Q` is true.\n"
"\n"
"2) If your goal is the possible conclusion of a theorem (which might have some\n"
"hypotheses), and if `h` is a *proof* of the theorem, then `apply h` will\n"
"apply the theorem to the goal. Sometimes it will prove it, and sometimes it\n"
"will *reduce* the goal of the level to some simpler goals.\n"
"\n"
"### Examples:\n"
"\n"
"1) (`apply` solving a goal.) `mem_univ` is the proof of the theorem `‚àÄ x : ùìß, x ‚àà univ`. In other words,\n"
"`mem_univ` is a *function*, which takes as input a term of type `ùìß` and\n"
"returns a proof that `x ‚àà univ`.\n"
"\n"
"So if you have `a : X` and your goal is to prove `‚ä¢ a ‚àà univ` then `exact mem_univ` will\n"
"*not work*, because `mem_univ` has a \"for all\" in, and the goal does not.\n"
"But `apply mem_univ` will work fine, as the `apply` tactic will figure out that\n"
"you want to set `x = a`.\n"
"\n"
"2) (`apply` changing a goal.) If your goal is `‚ä¢ A ‚à™ B = univ` then `apply univ_subset`\n"
"will change it to `univ ‚äÜ A ‚à™ B`, because `univ_subset` says that for all sets `S`,\n"
"`univ ‚äÜ S` implies `S = univ`. The goal is now slightly logically easier.\n"
"\n"
"3) (`apply ... at` changing a hypothesis.) If you have `h : S ‚äÜ T` and you\n"
"`rw [subset_def] at h`, you'll get `h : ‚àÄ (x : ùìß), x ‚àà S ‚Üí x ‚àà T`. If you\n"
"have a second hypothesis `haS : a ‚àà S` then `apply h at haS` will turn `haS`\n"
"into a now poorly-named proof of `a ‚àà T`.\n"
"\n"
"Similarly if `h‚ÇÅ : log 37 ‚àà S` then `apply h at h‚ÇÅ` will give you `h‚ÇÅ : log 37 ‚àà T`.\n"
"\n"
"### Bonus fact if you got to the end\n"
"\n"
"There's something in type theory called \"definitional equality\" which is part of\n"
"the wiring and is not mathematics in the traditional sense. It turns out\n"
"that `S ‚äÜ T` is *definitionally* equal to `‚àÄ (x : ùìß), x ‚àà S ‚Üí x ‚àà T`, so\n"
"actually if `h : S ‚äÜ T` then you can just `apply h` to change `‚ä¢ 42 ‚àà T` to\n"
"`‚ä¢ 42 ‚àà S`. For another example, go back to set world level 1 and try `intro x`\n"
"as your first move. What's going on is that the proof of `subset_def` is `rfl`."
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "## Summary\n"
"\n"
"If the goal is a statement `P`, then `exact h` will close the goal if `h` is a proof of `P`.\n"
"\n"
"### Example\n"
"\n"
"If the goal is `x ‚àà S` and you have a hypothesis `h : x ‚àà S`\n"
"then `exact h` will solve the goal.\n"
"\n"
"### Non-example\n"
"\n"
"If the goal is `x ‚àà S`, then `exact x ‚àà S` won't work. Exact eats a *proof*\n"
"of a mathematical result, not a *statement*.\n"
"\n"
"### Exact needs to be exactly right\n"
"\n"
"`mem_univ` is the theorem that `‚àÄ x : X, x ‚àà univ`. In other words, it is a *function*\n"
"which takes as input an element of `X` and returns a proof that `x ‚àà univ`.\n"
"\n"
"So if you have `a : X` and your goal is `a ‚àà univ` then `exact mem_univ` will *not work*,\n"
"because `mem_univ` has a \"for all\" in, and the goal does not. You want\n"
"to use `apply mem_univ` in this situation, as the `apply` tactic will figure out\n"
"that you want to set `x = a`."
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "`subset_def` is the proof of `(S ‚äÜ T) ‚Üî ‚àÄ x, x ‚àà S ‚Üí x ‚àà T`.\n"
"\n"
"If you're working with subsets from first principles, then `rw [subset_def]`\n"
"will change occurrences of `S ‚äÜ T` in the goal to `‚àÄ x, x ‚àà S ‚Üí x ‚àà T`.\n"
"\n"
"Variants:\n"
"\n"
"* `rw [subset_def] at h` (change the definition at hypothesis `h`)\n"
"* `rw [subset_def] at *` (change the definition everywhere)"
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "Every set $S$ is a subset of itself."
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "Every set $S$ is a subset of itself."
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "Start with `rw [subset_def]` to replace `S ‚äÜ S` with its definition."
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "Now we've got to prove something for all `x`, so `intro x`."
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "Now we assume `x ‚àà S` with `intro h`."
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "And now our goal is exactly `h`, so `exact h` or `apply h` will finish the level."
msgstr ""

#: Game.Levels.SetWorld.L01_subset_refl
msgid "Nice! Let's now prove another basic property of subsets."
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "Set inclusion is transitive"
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "In this level, we'll show the \"geometrically obvious\"\n"
"fact that if `S`, `T` and `U` are sets, with `S ‚äÜ T`\n"
"and `T ‚äÜ U`, then `S ‚äÜ U`."
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "If $S ‚äÜ T$ and $T\\subseteq U$ then $S\\subseteq U$."
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "If $S ‚äÜ T$ and $T\\subseteq U$ then $S\\subseteq U$."
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "Start with `rw [subset_def] at *` to replace all occurences of the `‚äÜ` symbol with\n"
"their definitions."
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "Now we've got to prove something for all `x`, so `intro x`."
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "Now we assume `x ‚àà S` with `intro h`"
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "Now we just have to put the pieces together.\n"
"You can either argue forwards, with `apply hST at h`,\n"
"or you can argue backwards with `apply hTU`."
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "Now figure out how to use `hTU` to finish things off."
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "`apply hTU at h` or `apply hTU` make progress. Then `exact h`"
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "Now figure out how to use `hST` to finish things off."
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "`apply hST at h` or `apply hST` make progress. Then `exact h`"
msgstr ""

#: Game.Levels.SetWorld.L02_subset_trans
msgid "Nice! Let's now prove another basic property of subsets."
msgstr ""

#: Game.Levels.SetWorld.L03_subset_antisymm
msgid "Set inclusion is antisymmetric"
msgstr ""

#: Game.Levels.SetWorld.L03_subset_antisymm
msgid "The subset relation `‚äÜ` is a *partial order*. This means that it's reflexive,\n"
"transitive, and antisymmetric. In this level we learn two new tactics\n"
"to prove that if `S ‚äÜ T` and `T ‚äÜ S` then `S = T`."
msgstr ""

#: Game.Levels.SetWorld.L03_subset_antisymm
msgid "## Summary\n"
"\n"
"If the goal is really two goals, for example `P ‚Üî Q` or `P ‚àß Q`, then `constructor`\n"
"it into two different goals.\n"
"\n"
"### Example\n"
"\n"
"`constructor` turns the goal `P ‚Üî Q` into the two goals `P ‚Üí Q` and `Q ‚Üí P`.\n"
"\n"
"### Example\n"
"\n"
"`constructor` turns the goal `P ‚àß Q` into the two goals `P` and `Q`."
msgstr ""

#: Game.Levels.SetWorld.L03_subset_antisymm
msgid "## Summary\n"
"\n"
"If the goal is the equality of two sets `S = T`, then `ext a` introduces a new variable `a`\n"
"and turns the goal into `a ‚àà S ‚Üî a ‚àà T`."
msgstr ""

#: Game.Levels.SetWorld.L03_subset_antisymm
msgid "If $S ‚äÜ T$ and $T\\subseteq S$ then $S = T$."
msgstr ""

#: Game.Levels.SetWorld.L03_subset_antisymm
msgid "If $S ‚äÜ T$ and $T\\subseteq S$ then $S = T$."
msgstr ""

#: Game.Levels.SetWorld.L03_subset_antisymm
msgid "We have to prove that two sets are equal. It's an axiom of mathematics\n"
"(\"set extensionality\") that two sets are equal if they have the same elements.\n"
"In Lean the `ext` tactic applies this axiom. Start with `ext a`."
msgstr ""

#: Game.Levels.SetWorld.L03_subset_antisymm
msgid "We now have to prove an if and only if statement `P ‚Üî Q`, which is the same as proving\n"
"`P ‚Üí Q` and `Q ‚Üí P`. Now use the `constructor` tactic to split the goal up into these two goals."
msgstr ""

#: Game.Levels.SetWorld.L03_subset_antisymm
msgid "This goal is going to follow from the fact that `S ‚äÜ T`. So let's `rw [subset_def] at hST`\n"
"to get it into a more useful form"
msgstr ""

#: Game.Levels.SetWorld.L03_subset_antisymm
msgid "You've seen this kind of goal before in the previous level. See if you can take it from here."
msgstr ""

#: Game.Levels.SetWorld.L03_subset_antisymm
msgid "Pro tip: you can solve `a ‚àà T ‚Üí a ‚àà S` with one tactic `apply hTS`! The reason this works\n"
"is that `T ‚äÜ S` is equal to `‚àÄ x, x ‚àà T ‚Üí x ‚àà S` *by definition*, so it is a theorem which\n"
"applies for all `x`, and in particular it applies for `x = a`, which is the goal."
msgstr ""

#: Game.Levels.SetWorld.L04_subset_univ
msgid "The \"universal set\""
msgstr ""

#: Game.Levels.SetWorld.L04_subset_univ
msgid "Every set in this world is a subset of `ùìß`, but `ùìß` is a *type*, not a set.\n"
"So what is the set which contains every element of `ùìß`? It's called `univ`. And\n"
"the axiom you need to know is `mem_univ (x : ùìß) : x ‚àà univ`. You should `apply mem_univ`\n"
"when faced with the goal `x ‚àà univ`."
msgstr ""

#: Game.Levels.SetWorld.L04_subset_univ
msgid "`mem_univ` is the proof of `‚àÄ x, x ‚àà univ`.\n"
"\n"
"When faced with a goal `a ‚àà univ`, you can `apply mem_univ` to close it. You can\n"
"also do `exact mem_univ a`."
msgstr ""

#: Game.Levels.SetWorld.L04_subset_univ
msgid "Any set `S` satisfies `S ‚äÜ univ`.\n"
"\n"
"More formally, `subset_univ : ‚àÄ (S : Set ùìß), S ‚äÜ univ`."
msgstr ""

#: Game.Levels.SetWorld.L04_subset_univ
msgid "$S ‚äÜ univ$."
msgstr ""

#: Game.Levels.SetWorld.L04_subset_univ
msgid "Try and the turn the goal into `x ‚àà univ` and then `apply mem_univ`."
msgstr ""

#: Game.Levels.SetWorld.L05_univ_subset
msgid "Nothing's bigger than the universal set"
msgstr ""

#: Game.Levels.SetWorld.L05_univ_subset
msgid "See if you can use the tactics we've learnt to prove that if `univ ‚äÜ S`\n"
"then `S = univ`."
msgstr ""

#: Game.Levels.SetWorld.L05_univ_subset
msgid "`univ_subset` is the proof that `univ ‚äÜ S ‚Üí S = univ`."
msgstr ""

#: Game.Levels.SetWorld.L05_univ_subset
msgid "Any set `S` satisfies `S ‚äÜ univ`."
msgstr ""

#: Game.Levels.SetWorld.L05_univ_subset
msgid "If $univ ‚äÜ S$ then $S = univ$."
msgstr ""

#: Game.Levels.SetWorld.L05_univ_subset
msgid "Try `rw [subset_def] at h`."
msgstr ""

#: Game.Levels.SetWorld.L05_univ_subset
msgid "Try `ext a`."
msgstr ""

#: Game.Levels.SetWorld.L05_univ_subset
msgid "Try `constructor`."
msgstr ""

#: Game.Levels.SetWorld.L05_univ_subset
msgid "Try `intro h2`"
msgstr ""

#: Game.Levels.SetWorld.L05_univ_subset
msgid "Try `apply mem_univ`"
msgstr ""

#: Game.Levels.SetWorld.L05_univ_subset
msgid "Can you finish in one line?"
msgstr ""

#: Game.Levels.SetWorld.L05_univ_subset
msgid "Try `apply ¬´{h}¬ª`."
msgstr ""

#: Game.Levels.SetWorld.L06_inter_comm
msgid "Intersections"
msgstr ""

#: Game.Levels.SetWorld.L06_inter_comm
msgid "The last thing we need to know about subsets is how to work with the intersection\n"
"`S ‚à© T` of two subsets `S` and `T`. The key lemma you need is\n"
"`mem_inter_iff x S T`, which is a proof of `x ‚àà S ‚à© T ‚Üî x ‚àà S ‚àß x ‚àà T`. That `‚àß` symbol\n"
"means \"and\"."
msgstr ""

#: Game.Levels.SetWorld.L06_inter_comm
msgid "## Summary\n"
"\n"
"If the goal is a true statement in pure logic, like `P ‚Üí (Q ‚Üí P)` or `P ‚àß Q ‚Üí Q ‚àß P`\n"
"(where `P` and `Q` can represent any mathematical true/false statements) then\n"
"the `tauto` tactic will solve it."
msgstr ""

#: Game.Levels.SetWorld.L06_inter_comm
msgid "`mem_inter_iff` is the proof of `‚àÄ x S T, x ‚àà S ‚à© T ‚Üî x ‚àà S ‚àß x ‚àà T`.\n"
"\n"
"Note that `mem_inter_iff` has three explicit inputs, `x`, `S` and `T`."
msgstr ""

#: Game.Levels.SetWorld.L06_inter_comm
msgid "`S ‚à© T = T ‚à© S`."
msgstr ""

#: Game.Levels.SetWorld.L06_inter_comm
msgid "`S ‚à© T = T ‚à© S`."
msgstr ""

#: Game.Levels.SetWorld.L06_inter_comm
msgid "Start with `ext a`."
msgstr ""

#: Game.Levels.SetWorld.L06_inter_comm
msgid "We are trying to get this goal into a form where the `tauto` tactic\n"
"will solve it. Click on the `tauto` tactic on the right to see what\n"
"it does. Then try `rw [mem_inter_iff]`"
msgstr ""

#: Game.Levels.SetWorld.L06_inter_comm
msgid "Now do it again, and the goal will be purely a logic goal."
msgstr ""

#: Game.Levels.SetWorld.L06_inter_comm
msgid "This has now got nothing to do with sets. Prove this logic goal with `tauto`."
msgstr ""

#: Game.Levels.SetWorld.L07_inter_subset_left
msgid "`S ‚à© T ‚äÜ S`"
msgstr ""

#: Game.Levels.SetWorld.L07_inter_subset_left
msgid "Let's prove `inter_subset_left`, the statement that `S ‚à© T ‚äÜ S`."
msgstr ""

#: Game.Levels.SetWorld.L07_inter_subset_left
msgid "## Summary\n"
"\n"
"If the goal is a true statement in pure logic, like `P ‚Üí (Q ‚Üí P)` or `P ‚àß Q ‚Üí Q ‚àß P`\n"
"(where `P` and `Q` can represent any mathematical true/false statements) then\n"
"the `tauto` tactic will solve it."
msgstr ""

#: Game.Levels.SetWorld.L07_inter_subset_left
msgid "`S ‚à© T ‚äÜ S`."
msgstr ""

#: Game.Levels.SetWorld.L07_inter_subset_left
msgid "`S ‚à© T ‚äÜ S`."
msgstr ""

#: Game.Levels.SetWorld.L07_inter_subset_left
msgid "There's a subtlety here, so let me talk you through it. Start of course with\n"
"`rw [subset_def]`."
msgstr ""

#: Game.Levels.SetWorld.L07_inter_subset_left
msgid "Now you can see `x ‚àà S ‚à© T` in the goal, but `rw [mem_inter_iff]` will *fail*, because\n"
"\"`rw` doesn't work under binders\". In other words, that `x` isn't a variable yet,\n"
"it's a \"for all `x`\". Make it a variable with `intro x`."
msgstr ""

#: Game.Levels.SetWorld.L07_inter_subset_left
msgid "Now you have an actual `x : ùìß` in your list of variables, so `rw [mem_inter_iff]` will\n"
"work."
msgstr ""

#: Game.Levels.SetWorld.L07_inter_subset_left
msgid "Now finish this pure logic goal in one line."
msgstr ""

#: Game.Levels.SetWorld.L08_subset_inter
msgid "If `A ‚äÜ S` and `A ‚äÜ T` then `A ‚äÜ S ‚à© T`."
msgstr ""

#: Game.Levels.SetWorld.L08_subset_inter
msgid "The final level in this tutorial is one we'll need later, so we'd\n"
"better prove it now. It's a simple criterion for proving `A ‚äÜ S ‚à© T`, namely\n"
"checking that `A ‚äÜ S` and `A ‚äÜ T`."
msgstr ""

#: Game.Levels.SetWorld.L08_subset_inter
msgid "If `A ‚äÜ S` and `A ‚äÜ T` then `A ‚äÜ S ‚à© T`."
msgstr ""

#: Game.Levels.SetWorld.L08_subset_inter
msgid "If `A ‚äÜ S` and `A ‚äÜ T` then `A ‚äÜ S ‚à© T`."
msgstr ""

#: Game.Levels.SetWorld.L08_subset_inter
msgid "I would start with `rw [subset_def] at *`. If you find yourself\n"
"later on with the goal `x ‚àà S ‚àß x ‚àà T`, then\n"
"use the `constructor` tactic to break into two goals `x ‚àà S` and `x ‚àà T`."
msgstr ""

#: Game.Levels.SetWorld.L08_subset_inter
msgid "That's enough practice with sets. You can either now do some practice\n"
"with functions in Function World, or you can start to learn about filters\n"
"in Filter World."
msgstr ""

#: Game.Levels.SetWorld
msgid "Set World"
msgstr ""

#: Game.Levels.SetWorld
msgid "In this tutorial level we'll learn about sets, subsets, and the intersection of two sets.\n"
"\n"
"Our sets will all be subsets of a fixed \"base set\" `ùìß`.\n"
"In particular, whenever we say \"let `S` be a set\" in this level, we mean \"let `S` be a set\n"
"of elements of `ùìß`\", and we write `S : Set ùìß`.\n"
"\n"
"In Lean the base set `ùìß` is called a *type*. If you're used to also thinking of `ùìß` as a set,\n"
"this shouldn't cause any problems, but there is one notational difference. Lean uses the notation\n"
"`x : ùìß` to mean that `x` is an element of the base type `ùìß`, but for `S` a set, Lean uses\n"
"the notation `x ‚àà S` to mean that `x` is an element `S`.\n"
"\n"
"Click \"Start ‚Üí\" to continue."
msgstr ""

#: Game.Levels.FilterWorld.L01_univ_mem_principal
msgid "The filter associated to a set."
msgstr ""

#: Game.Levels.FilterWorld.L01_univ_mem_principal
msgid "Like in Set World, we'll fix a \"base set\" `ùìß`, and all our\n"
"sets will be subsets of `ùìß`.\n"
"\n"
"Let `A` be a subset of `ùìß`. Here's the key definition.\n"
"\n"
"Let `ùìü A` denote the set of *all* the subsets of `ùìß` which contain `A`. In\n"
"particular, `ùìü A` is a *set of sets*. It's called `ùìü` because this\n"
"is the *principal filter* associated to `A`.\n"
"\n"
"The name of the key fact you need to know about `ùìü A`, namely\n"
"`S ‚àà ùìü A ‚Üî A ‚äÜ S`, is called `mem_principal`. This is true by definition.\n"
"\n"
"In the first three levels of this game, we'll prove three easy facts\n"
"about `ùìü A` using `mem_principal`. The first one is about the set\n"
"`univ` whose elements are all of `ùìß`."
msgstr ""

#: Game.Levels.FilterWorld.L01_univ_mem_principal
msgid "`mem_principal` is the proof that `S ‚àà ùìü A ‚Üî A ‚äÜ S`. This is true\n"
"because it's precisely the *definition* of `ùìü A`."
msgstr ""

#: Game.Levels.FilterWorld.L01_univ_mem_principal
msgid "`univ` is an element of `ùìü A`."
msgstr ""

#: Game.Levels.FilterWorld.L01_univ_mem_principal
msgid "Start with `rw [mem_principal]`."
msgstr ""

#: Game.Levels.FilterWorld.L01_univ_mem_principal
msgid "Now `apply` a theorem we proved already to finish the job."
msgstr ""

#: Game.Levels.FilterWorld.L01_univ_mem_principal
msgid "Let's now prove two more basic facts about `ùìü A`."
msgstr ""

#: Game.Levels.FilterWorld.L02_mem_principal_of_superset
msgid "Supersets and filters."
msgstr ""

#: Game.Levels.FilterWorld.L02_mem_principal_of_superset
msgid "In this level, we'll show that if `S ‚àà ùìü A` then any\n"
"bigger set `T ‚äá S` is also in `ùìü A`."
msgstr ""

#: Game.Levels.FilterWorld.L02_mem_principal_of_superset
msgid "If `S ‚àà ùìü A` and `S ‚äÜ T` then `T ‚àà ùìü A`."
msgstr ""

#: Game.Levels.FilterWorld.L02_mem_principal_of_superset
msgid "Start with `rw [mem_principal] at *` to remove all mention of `ùìü`."
msgstr ""

#: Game.Levels.FilterWorld.L02_mem_principal_of_superset
msgid "Now you can finish with `exact subset_trans hAS hST`"
msgstr ""

#: Game.Levels.FilterWorld.L02_mem_principal_of_superset
msgid "Now let's show a fact about `ùìü A` and intersections."
msgstr ""

#: Game.Levels.FilterWorld.L03_inter_mem_principal
msgid "Intersections and filters."
msgstr ""

#: Game.Levels.FilterWorld.L03_inter_mem_principal
msgid "In this level, we'll show that if `S ‚àà ùìü A` and `T ‚àà ùìü A`\n"
"then `S ‚à© T ‚àà ùìü A`."
msgstr ""

#: Game.Levels.FilterWorld.L03_inter_mem_principal
msgid "If `S ‚àà ùìü A` and `T ‚àà ùìü A` then `S ‚à© T ‚àà ùìü A`."
msgstr ""

#: Game.Levels.FilterWorld.L03_inter_mem_principal
msgid "Start with `rw [mem_principal] at *` to remove all mention of `ùìü`."
msgstr ""

#: Game.Levels.FilterWorld.L03_inter_mem_principal
msgid "Now you can `apply subset_inter`"
msgstr ""

#: Game.Levels.FilterWorld.L03_inter_mem_principal
msgid "You just proved the three axioms of a filter."
msgstr ""

#: Game.Levels.FilterWorld.L04_univ_mem_nhds_infinity
msgid "Infinitely big numbers."
msgstr ""

#: Game.Levels.FilterWorld.L04_univ_mem_nhds_infinity
msgid "Let's see an example of a filter which isn't principal,\n"
"the \"neighbourhoods of infinity\" filter `ùìù‚àû` on the natural numbers."
msgstr ""

#: Game.Levels.FilterWorld.L04_univ_mem_nhds_infinity
msgid "`mem_ninf` is the proof that `S ‚àà ùìù‚àû ‚Üî ‚àÉ N, ‚àÄ i, N ‚â§ i ‚Üí i ‚àà S`. This is\n"
"true because it's precisely the *definition* of `ùìù‚àû`."
msgstr ""

#: Game.Levels.FilterWorld.L04_univ_mem_nhds_infinity
msgid "## Summary\n"
"\n"
"If the goal is `‚àÉ N, blah blah blah` then to prove such a statement, you\n"
"have to show that some `N` exists which makes `blah blah blah` true.\n"
"If you think `N = 37` works, then `use 37` will remove the `‚àÉ`\n"
"and replace all `N`s in `blah blah blah` by 37.\n"
"\n"
"Note: `use` is a dangerous tactic. If you `use` the wrong number,\n"
"you can turn a true goal into a false one.\n"
"\n"
"### Example\n"
"\n"
"If the goal is `‚àÉ N, N + N = 4` then `use 2` will turn the\n"
"goal into `2 + 2 = 4`, and `use 37` will turn the goal\n"
"into `37 + 37 = 4`."
msgstr ""

#: Game.Levels.FilterWorld.L04_univ_mem_nhds_infinity
msgid "`univ` is an element of `ùìù‚àû`."
msgstr ""

#: Game.Levels.FilterWorld.L04_univ_mem_nhds_infinity
msgid "Start with `rw [mem_ninf]`."
msgstr ""

#: Game.Levels.FilterWorld.L04_univ_mem_nhds_infinity
msgid "To prove an \"exists\" goal we use the `use` tactic. Try `use 37`\n"
"and Lean will replace `N` with `37`."
msgstr ""

#: Game.Levels.FilterWorld.L04_univ_mem_nhds_infinity
msgid "Can you take it from here?"
msgstr ""

#: Game.Levels.FilterWorld.L04_univ_mem_nhds_infinity
msgid "Let's now prove the other two filter axioms for `ùìù‚àû`."
msgstr ""

#: Game.Levels.FilterWorld.L05_mem_nhds_infinity_of_superset
msgid "The superset axiom for `ùìù‚àû`."
msgstr ""

#: Game.Levels.FilterWorld.L05_mem_nhds_infinity_of_superset
msgid "In this level, we'll show that if `S ‚àà ùìù‚àû` then any\n"
"bigger set `T ‚äá S` is also in `ùìù‚àû`."
msgstr ""

#: Game.Levels.FilterWorld.L05_mem_nhds_infinity_of_superset
msgid "## Summary\n"
"\n"
"If you have a *hypothesis* `h : ‚àÉ N, blah blah blah` then the hypothesis says\n"
"that *some* `N` exists with some property. But you don't *actually have* an `N`\n"
"in your variables, just a promise that it exists.\n"
"\n"
"Get that `N` with `cases' h with N hN`."
msgstr ""

#: Game.Levels.FilterWorld.L05_mem_nhds_infinity_of_superset
msgid "If `S ‚àà ùìù‚àû` and `S ‚äÜ T` then `T ‚àà ùìù‚àû`."
msgstr ""

#: Game.Levels.FilterWorld.L05_mem_nhds_infinity_of_superset
msgid "Start with `rw [mem_ninf] at *` to remove all mention of `ùìù‚àû`."
msgstr ""

#: Game.Levels.FilterWorld.L05_mem_nhds_infinity_of_superset
msgid "You now need to get to that `N` whose existence is guaranteed by `hS`. Do\n"
"this with `cases' hS with D hD`"
msgstr ""

#: Game.Levels.FilterWorld.L05_mem_nhds_infinity_of_superset
msgid "I didn't write any more hints yet, but can you do it from here? Tell me where you get stuck\n"
"and I'll put more hints in!"
msgstr ""

#: Game.Levels.FilterWorld.L05_mem_nhds_infinity_of_superset
msgid "Just `ùìù‚àû` and intersections left!"
msgstr ""

#: Game.Levels.FilterWorld
msgid "Filter World"
msgstr ""

#: Game.Levels.FilterWorld
msgid "A filter on `ùìß` should be thought of as a *generalised subset*\n"
"of `ùìß`.\n"
"\n"
"Every subset of `ùìß` gives you a filter on `ùìß`, and at the start of this world\n"
"we're going to explain how this works.\n"
"\n"
"Click \"Start ‚Üí\" to continue."
msgstr ""

#: Game.Levels.MinMaxWorld.L01_max
msgid "The `max` tactic."
msgstr ""

#: Game.Levels.MinMaxWorld.L01_max
msgid "In this chapter we develop a basic interface for the `max a b` and `abs a`\n"
"function on the real numbers. Before we start, you will need to know\n"
"the basic API for `‚â§` and `<`, which looks like this:\n"
"\n"
"`example : a ‚â§ b ‚Üí b ‚â§ c ‚Üí a ‚â§ c := le_trans`\n"
"\n"
"`example : a ‚â§ b ‚Üí b ‚â§ a ‚Üí a = b := le_antisymm`\n"
"\n"
"`example : a ‚â§ b ‚à® b ‚â§ a := le_total a b`\n"
"\n"
"`example : a < b ‚Üî a ‚â§ b ‚àß a ‚â† b := lt_iff_le_and_ne`\n"
"\n"
"`example : a ‚â§ b ‚Üí b < c ‚Üí a < c := lt_of_le_of_lt`\n"
"\n"
"`example : a < b ‚Üí b ‚â§ c ‚Üí a < c := lt_of_lt_of_le`"
msgstr ""

#: Game.Levels.MinMaxWorld
msgid "MinMax World"
msgstr ""

#: Game.Levels.MinMaxWorld
msgid "Lean has lots of tactics, and sometimes students learn about tactics which\n"
"they want to learn in the Filter Game but *can't use* because they\n"
"haven't been introduced yet.\n"
"\n"
"In MinMax World we have levels which introduce new tactics. The more\n"
"you do, the more \"power\" you will have available to you.\n"
"\n"
"Click \"Start ‚Üí\" to continue."
msgstr ""

#: Game
msgid "The Filter Game"
msgstr ""

#: Game
msgid "# Welcome to the Filter Game\n"
"\n"
"## What is this game?\n"
"\n"
"There's a mathematical object called a *filter*. It doesn't get much love.\n"
"It's not often taught in an undergraduate degree. Furthermore, there are\n"
"bad ways to teach it, which can end up with you being more confused than\n"
"when you started. Indeed, the author of this game was confused about filters\n"
"for many years.\n"
"\n"
"This game is an attempt to explain filters in an intuitive way, as\n"
"\"generalised sets\". If you have been brainwashed by the textbook\n"
"approach to mathematics, you'll know that infinity is not a number,\n"
"that `dy/dx` doesn't mean `dy` divided by `dx` because `dx` isn't\n"
"a number, and that `0.999999999999999... = 1` because the difference\n"
"between them is infinitely small, and there are no infinitely small\n"
"numbers apart from `0`. Well, filters let you recover these intuitive\n"
"ideas in a rigorous way which doesn't lead to contradictions.\n"
"\n"
"## What are the prerequisites for playing?\n"
"\n"
"First, there are some mathematical prerequisites. You will need to know\n"
"about the abstract concepts of sets and subsets, and functions between sets.\n"
"You don't need much more than that. You can learn about these ideas\n"
"in any first course or textbook on abstract mathematics, for example\n"
"Martin Liebeck's book \"A Concise Introduction to Pure Mathematics\".\n"
"\n"
"And then there are some Lean prerequisites. Lean is an interactive\n"
"theorem prover, and this game is written in Lean; you can see\n"
"the source code to the game [here](https://github.com/kbuzzard/FilterGame)\n"
"on GitHub, and even clone it yourself and add your own levels if you want.\n"
"In this game I will assume you know the following basic Lean tactics:\n"
"`intro`, `apply`, `exact` and `rw`. If you don't know these tactics, then you could\n"
"try playing a few worlds in the [Natural Number Game](https://adam.math.hhu.de/#/g/leanprover-community/nng4).\n"
"If you've platyed through Tutorial World, Addition World and Implication World in that\n"
"game, then you know enough about Lean to play the Filter Game.\n"
"\n"
"## Getting started\n"
"\n"
"If you satisfy the prerequisites, get started by clicking on `Set World`!"
msgstr ""

#: Game
msgid "Version 0.1.0: experimental prerelease.\n"
"\n"
"## History\n"
"\n"
"The Filter Game has been a long time coming. I (Kevin Buzzard)\n"
"started experimenting with it in about 2020. The first Lean 4 project\n"
"I ever embarked on in 2021 was some Filter Game levels (I had to define\n"
"a filter in Lean 4 as part of it!). I then supervised a second\n"
"year group project on filters in 2023, and Billy Miao put together\n"
"a preliminary version (in Lean 3) as part of the project. I thank\n"
"Billy Miao, Lily Frost, Yichen Feng and Archie Prime for their thoughts on\n"
"how things should be put together.\n"
"\n"
"What finally pushed this game into something which I felt was finally\n"
"ready, was the London Mathematical Society, who invited me to give\n"
"a course as part of their 2024 Summer School at the University of Essex.\n"
"I chose to give a course on filters, and made this game as part of\n"
"the learning experience for the students."
msgstr ""

#: Game
msgid "A Lean game introducing filters."
msgstr ""

#: Game
msgid "This game introduces the mathematical concept of a filter.\n"
"You should be familiar with some basic Lean tactics (for example, those\n"
"used in Addition World and Inequality World in the Natural Number Game),\n"
"and mathematically you should be happy with the ideas of abstract sets\n"
"and functions."
msgstr ""
